from collections import OrderedDict

from django.db.models.aggregates import Count

from blackwidow.engine.routers.database_router import BWDatabaseRouter
from undp_nuprp.reports.config.constants.pg_survey_constants import PG_MPI_CATEGORIES
from undp_nuprp.reports.utils.thousand_separator import thousand_separator


def get_pghh_mpi_column_chart_data(wards=list(), from_time=None, to_time=None):
    from undp_nuprp.survey.models.indicators.pg_mpi_indicator.mpi_indicator import PGMPIIndicator
    mpi_indicator_domain = PGMPIIndicator.get_role_based_queryset(queryset=PGMPIIndicator.objects.filter(
        survey_response__survey__name='PG Member Survey Questionnaire')).using(
        BWDatabaseRouter.get_read_database_name())
    if from_time and to_time:
        mpi_indicator_domain = mpi_indicator_domain.filter(
            survey_response__survey_time__gte=from_time, survey_response__survey_time__lte=to_time)
    if wards:
        mpi_indicator_domain = mpi_indicator_domain.filter(
            survey_response__address__geography__parent__parent_id__in=wards)

    queryset = mpi_indicator_domain.values('mpi_score').annotate(
        count=Count('primary_group_member_id', distinct=True))

    mpi_dict = OrderedDict()
    all_categories = PG_MPI_CATEGORIES
    for c in all_categories:
        if c not in mpi_dict.keys():
            mpi_dict[c] = 0

    total_pg = 0
    for data in queryset:
        try:
            mpi_score = float(data.get('mpi_score'))
        except:
            continue
        score = ''
        if mpi_score:
            base = int(mpi_score) // 10 * 10
            score = '%d-%.1f' % (base, base + 9.9)
        if not score:
            continue

        if score not in mpi_dict.keys() and score:
            mpi_dict[score] = 0
        if score:
            mpi_dict[score] += data.get('count')
            total_pg += data.get('count')

    data = [
        {
            'name': '% of PG',
            'data': [round(((d / total_pg) * 100)) for d in mpi_dict.values()]
        }
    ]
    return data, all_categories


def get_pghh_mpi_table_data(wards=list(), from_time=None, to_time=None):
    from undp_nuprp.survey.models.indicators.pg_mpi_indicator.mpi_indicator import PGMPIIndicator
    mpi_indicator_domain = PGMPIIndicator.get_role_based_queryset(queryset=PGMPIIndicator.objects.filter(
        survey_response__survey__name='PG Member Survey Questionnaire')).using(
        BWDatabaseRouter.get_read_database_name())
    if from_time and to_time:
        mpi_indicator_domain = mpi_indicator_domain.filter(
            survey_response__survey_time__gte=from_time, survey_response__survey_time__lte=to_time)
    if wards:
        mpi_indicator_domain = mpi_indicator_domain.filter(
            survey_response__address__geography__parent__parent_id__in=wards)

    queryset = mpi_indicator_domain.values(
        'mpi_score', 'primary_group_member__assigned_to__parent__address__geography__parent__name'
    ).annotate(
        count=Count('primary_group_member_id', distinct=True)
    ).order_by(
        'primary_group_member__assigned_to__parent__address__geography__parent__name'
    )

    poverty_index_dict = OrderedDict()
    poverty_index_list = ['MPI below 20', 'MPI 20 or above']
    for _poverty_index in poverty_index_list:
        poverty_index_dict[_poverty_index] = 0

    for data in queryset:
        try:
            pg_score = float(data.get('mpi_score'))
        except:
            continue
        score = ''
        if pg_score >= 0:
            if 19.9 >= pg_score >= 0:
                score = 'MPI below 20'
            elif pg_score >= 20:
                score = 'MPI 20 or above'
        if not score:
            continue

        if score not in poverty_index_dict.keys() and score:
            poverty_index_dict[score] = 0
        if score:
            poverty_index_dict[score] += data.get('count')

    table_data = OrderedDict()
    for data in queryset:
        city = data.get('primary_group_member__assigned_to__parent__address__geography__parent__name')
        if not city:
            continue
        try:
            pg_score = float(data.get('mpi_score'))
        except:
            continue
        score = ''
        if pg_score >= 0:
            if 19.9 >= pg_score >= 0:
                score = 'MPI below 20'
            elif pg_score >= 20:
                score = 'MPI 20 or above'

        count = data.get('count')
        if city not in table_data.keys():
            table_data[city] = OrderedDict()
            for c in poverty_index_dict.keys():
                table_data[city][c] = 0

        if score:
            table_data[city][score] += (count if count else 0)

    table_data['Total'] = OrderedDict()
    for c in poverty_index_dict.keys():
        table_data['Total'][c] = poverty_index_dict[c]

    city_pg_dict = dict()
    all_cities_pgm = 0
    for data in queryset:
        city = data.get('primary_group_member__assigned_to__parent__address__geography__parent__name')
        count = data.get('count')
        if not city or not count:
            continue
        if city is not None and city not in city_pg_dict.keys():
            city_pg_dict[city] = 0
        city_pg_dict[city] += count
        all_cities_pgm += count

    response_data = list()
    table_headings = list()
    # prepare table headings for both html & exportable table
    for _item in poverty_index_dict.keys():
        table_headings.append({
            'column_name': str(_item),
            'extra_column_name': str(_item) + "(%)",
            'split': 'true'
        })
    response_data.append((['City Corporation', ] + table_headings))
    for key, value in table_data.items():
        li = [str(key)]
        for k, v in value.items():
            if key in city_pg_dict.keys():
                if city_pg_dict[key] > 0:
                    li.append("{0:.0f}%".format(float(v) / city_pg_dict[key] * 100) + ' (' + thousand_separator(int(v)) + ')')
            else:
                if all_cities_pgm > 0:
                    li.append("{0:.0f}%".format(float(v) / all_cities_pgm * 100) + ' (' + thousand_separator(int(v)) + ')')
        response_data.append(li)
    return response_data
