# Created by shamilsakib at 7/14/2016

import copy
import os
import re
from collections import OrderedDict

from django.core.management.base import BaseCommand

from config.apps import INSTALLED_APPS as PROJECT_APPS

PROJECT_ROOT = os.path.abspath(".")


class Command(BaseCommand):
    ignoring_folders = ['migrations', 'management', 'static', 'templates', '__pycache__', 'contracts', 'managers',
                        'generics',
                        'static', 'templates', 'static_media']
    generating_folders = ['models', 'views', 'forms', 'reports']
    ignore_files = ['translation.py', 'urls.py', 'settings.py', 'manage.py']
    _class_name_parser = [
        re.compile('^class(\s)+(?P<class_name>(\w)+)\([a-zA-Z0-9_.]*(,(\s)*([a-zA-Z0-9_.])+)*\)')
    ]
    _check_if_meta = re.compile('(\s)*class(\s)+Meta')
    _import_parser = \
        re.compile('^from(\s)+(?P<view_package>(\w)+.*(\s))+import(\s)+(?P<class_name>(\w)+(,\s\w+)*)')

    def __init__(self, *args, **kwargs):
        super(Command, self).__init__(*args, **kwargs)
        self.requires_system_checks = False
        self.can_import_settings = False
        self.leave_locale_alone = True

    def is_matched(self, path, items):
        _relative_path = path.replace(PROJECT_ROOT + os.sep, '')
        _file = list(
            filter(lambda a: re.search((os.path.normpath(a) + os.sep).replace('\\', '\\\\') + '(.+)',
                                       _relative_path) is not None,
                   items))
        return len(_file) > 0

    def clear_inits(self, init_root, **options):
        _init_path = os.path.join(init_root, '__init__.py')
        self.clear_init_content(_init_path)

        for _inner_folders in filter(lambda it: os.path.isdir(os.path.join(init_root, it)) and
                        it != '__pycache__', os.listdir(init_root)):
            if self.is_matched(os.path.join(init_root, _inner_folders), self.generating_folders) or \
                    options.get('recursive_clear', False):
                opts = copy.deepcopy(options)
                opts.update({
                    'recursive_clear': True
                })
                self.clear_inits(os.path.join(init_root, _inner_folders), **opts)
            else:
                self.clear_inits(os.path.join(init_root, _inner_folders), **options)

    def clear_init_content(self, path):
        _init_file = open(path, 'w+')
        _init_file.write('__author__ = "generated by make_init"\n')
        _init_file.close()

    def generate_inits(self, path, app, top=False, **options):
        all_classes = OrderedDict()

        _init_path = os.path.join(path, '__init__.py')

        for _class_file in filter(lambda a: os.path.isdir(os.path.join(path, a)) and
                        a != '__pycache__', os.listdir(path)):
            if self.is_matched(os.path.join(path, _class_file), self.generating_folders) or \
                    options.get('recursive_generate', False):
                opts = copy.deepcopy(options)
                opts.update({
                    'recursive_generate': True
                })
                values = self.generate_inits(os.path.join(path, _class_file), app, top=False, **opts)
                all_classes.update(values[0])
            else:
                values = self.generate_inits(os.path.join(path, _class_file), app, **options)
                all_classes.update(values[0])

        if 'clean' in options and options['clean']:
            self.stdout.write(_init_path.replace(PROJECT_ROOT + os.sep, '') + "  ...  cleaned")
            return [[], []]

        for _class_file in filter(lambda a: not os.path.isdir(a), os.listdir(path)):
            if _class_file.endswith(".py") and _class_file != '__init__.py' and _class_file[-4:] != '.pyc' \
                    and not self.is_matched(os.path.join(path, _class_file), self.ignoring_folders):
                if _class_file.replace(path, '') in self.ignore_files:
                    continue
                _path = os.path.join(path, _class_file)
                with open(_path) as _file:
                    try:
                        _import = os.path.join(path, _class_file[:-3]) \
                            .replace(PROJECT_ROOT + os.sep, '').replace(os.sep, '.')
                        self_package_imports = []
                        for line in _file:
                            try:
                                if line.startswith('from'):
                                    importing = self._import_parser.search(line)
                                    if importing is not None:
                                        package = importing.group('view_package').strip()
                                        if package.startswith(app):
                                            import_class = importing.group('class_name').strip().split(',')
                                            for _class in import_class:
                                                self_package_imports.append(_class.strip())
                                        continue
                                for c in self._class_name_parser:
                                    result = c.search(line)
                                    if result is not None and self._check_if_meta.search(line) is None:
                                        all_classes[result.group('class_name')] = (_import, self_package_imports)
                            except Exception as exp:
                                self.stdout.write(str(exp))
                        _file.close()
                    except Exception as exp:
                        self.stdout.write(str(exp))
                        _file.close()
        if top and len(all_classes) > 0 and not options.get('cascade', False):
            self.stdout.write(
                _init_path.replace(PROJECT_ROOT + os.sep, '') + " ... " + str(len(all_classes)) + " classes added.")
            self.write_imports(_init_path, all_classes)
            self.write_classes(_init_path, all_classes)
        return [all_classes]

    def write_imports(self, path, classes):
        _init_file = open(path, '+w')

        class_list = list(classes.keys())
        index = 0
        while len(class_list) > 0:
            target = class_list[0]
            if target in classes:
                importing_classes = classes[target][1]
                index = 0
                while len(importing_classes) > 0:
                    _t = importing_classes[0]
                    if _t not in class_list:
                        importing_classes.remove(_t)
                        continue
                    target = _t
                    if target in classes:
                        importing_classes = classes[target][1]
                    index += 1
                    if index > 500:
                        break
            if index > 500:
                break
            _init_file.write("from " + classes[target][0] + " import " + target)
            _init_file.write("\n")
            class_list.remove(target)

        if index > 500:
            self.stdout.write('While generating ' + path + ', we have found circular dependency in class files.')

        _init_file.write('\n__author__ = "generated by make_init"\n')
        _init_file.close()

    def write_classes(self, path, classes):
        _init_file = open(path, 'a')
        index = 0
        class_list = list(classes.keys())
        for _class in class_list:
            if index == 0:
                _init_file.write('\n__all__ = [\'' + _class + '\']\n')
                index = 1
            else:
                _init_file.write('__all__ += [\'' + _class + '\']\n')

        _init_file.close()

    def handle(self, *args, **options):
        for app in PROJECT_APPS:
            for folder in self.generating_folders:
                folder_path = os.path.join(app.replace('.', os.sep), folder)
                if not os.path.exists(folder_path):
                    os.makedirs(folder_path)
                self.generate_inits(os.path.join(PROJECT_ROOT, os.path.normpath(folder_path)), app + '.' + folder,
                                    top=True, **options)
